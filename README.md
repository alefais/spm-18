# spm-exercises2018
Homework of the Parallel and Distributed Systems: Paradigms and Models course of the Computer Science and Networking Master's Degree @ University of Pisa

| <b>Homework number</b> | <b>Language/Framework/Tool</b> | <b>Description</b> |
| ---------- | ----------------------- | ----------- |
| 1 | C++ | A program that given a stream of std::vector<double> elements applies two functions (`f1(x) = x + 1` and `f2(x) = 2 * x`) over all the items of each vector in the stream. The program must use only C++ base mechanisms and libraries. The computation has to be implemented in a sequential way and in a parallel way. The parallel computation has been implemented as a four stage pipeline on a shared memory multicore: STAGE1 generates a stream of m vectors of n items each (randomly filled), STAGE2 increases all the items in each input vector, STAGE3 doubles all the items in each input vector, STAGE4 prints the input vectors contents on screen. The performance has been measured in terms of scalability, speedup and efficiency. |
| 2 | C++ | A program that computes in parallel a set of independent tasks, initially stored in a shared data structure, and delivers results using a second shared data structure. The program has been implemented using only C++ standard mechanisms and threads. An input task is given by an integer number N and the result to compute is the number of prime numbers included in range [1-N]. The initial set of tasks is picked up randomly in the range [1-10K]. Two different implementations of the workers has been provided: <ul><li>SEQUENTIAL: a worker first checks in the collection of the results if its current task has already been computed by another worker, if yes its computation is done, otherwise it will look for the biggest task computed since now that is smaller than its task and computes the number of primes only in a sub interval of [1, N]. <b>Example:</b> worker 0 receives task 100 and it has to compute the number of prime numbers in the interval [1, 100]; he finds out that task 100 has not been computed yet and starts looking for the biggest already computed task that is smaller than 100 (assume it is 93); he finds that task 93 has already been computed so it will count the number of prime numbers in the range [94, 100] and its final result will be the sum of the number of prime numbers in [1, 93] and the number of prime numbers in [94, 100].</li><li>SEQUENTIAL OPTIMIZED: each worker implements the [sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) to compute the number of prime numbers between 1 and the value of its received task.
Some delay can be added in the procedure obtaining a task to be computed in order to observe the impact on scalability. Load balancing of the workers has been implemented.</li></ul> |
| 3 | C++ | A program that implements a parallel [Google MapReduce](https://en.wikipedia.org/wiki/MapReduce) pattern using C++ base mechanisms only. The program takes as input two filenames: one is the file that has to be processed and the other is the file used to store the results. Given the input file, a <b>mapper</b> function will process lines of the file and produce a set of <Tkey, Tvalue> pairs. Given the set of pairs, a <b>reducer</b> function will apply a reduce operation to all the pairs with the same key value. All the computation is contained in a method with signature `void compute()` that writes the results in the output file out of the lines of the input file. |